‚úÖ What is a MVVM / MVP / MVI/ VIPER?
	These are UI architectural patterns designed to:
		‚Ä¢ Separate concerns (UI, business logic, data)
		‚Ä¢ Improve testability, scalability, and maintainability


1. üßë‚Äçüè´ MVP (Model-View-Presenter)
	‚û§ Analogy:
			Think of a teacher (Presenter), a student (View), and a library (Model).

		The student (View) asks the teacher (Presenter) for help, and the teacher fetches the information from the library (Model) and explains it back.

	‚û§ Components:
		‚Ä¢ Model ‚Äì Business/data layer
		‚Ä¢ View ‚Äì UI (Activity/Fragment/View)
		‚Ä¢ Presenter ‚Äì Middleman between View and Model

	‚û§ Flow:
		1. User interacts with View.
		2. View delegates the action to Presenter.
		3. Presenter fetches/updates Model.
		4. Presenter updates the View.

	‚û§ Use Case:
		‚Ä¢ Legacy Android projects (before architecture components)
		‚Ä¢ Good fit when using Java
		‚Ä¢ Testable Presenter (without Android dependencies)

	‚û§ Pros:
		‚Ä¢ Good separation
		‚Ä¢ Easy to unit test Presenter
		‚Ä¢ No direct dependency between View and Model

	‚û§ Cons:
		‚Ä¢ Presenter can become bloated
		‚Ä¢ View has to handle lifecycle manually


2. üß† MVVM (Model-View-ViewModel)
	‚û§ Analogy:
		Like a virtual assistant (ViewModel) behind the screen ‚Äî the user (View) speaks a command, and the assistant interprets and updates things in the background, updating the UI when data changes.

	‚û§ Components:
		‚Ä¢ Model ‚Äì Data layer
		‚Ä¢ View ‚Äì UI layer
		‚Ä¢ ViewModel ‚Äì Exposes observable data and business logic

	‚û§ Flow:
		1. View observes data from ViewModel (e.g. LiveData, StateFlow).
		2. User interaction is passed to ViewModel.
		3. ViewModel updates Model and updates observed state.
		4. View updates automatically based on observable changes.

	‚û§ Use Case:
		‚Ä¢ Android with Jetpack (LiveData, ViewModel, Compose)
		‚Ä¢ Reactive UIs (data-binding, Compose)
		‚Ä¢ Modern architecture

	‚û§ Pros:
		‚Ä¢ Lifecycle-aware
		‚Ä¢ Loose coupling
		‚Ä¢ Reactive, declarative UI updates

	‚û§ Cons:
		‚Ä¢ Harder to test when tightly coupled with LiveData
		‚Ä¢ Two-way binding can get messy
		‚Ä¢ ViewModel can grow too big


3. üîÅ MVI (Model-View-Intent)
	‚û§ Analogy:
		Like Redux or a robot waiter: you give a command (Intent), the system calculates the new state (Model) and updates the UI (View) with a new snapshot. State is immutable and unidirectional.

	‚û§ Components:
		‚Ä¢ Model ‚Äì Immutable state of the screen
		‚Ä¢ View ‚Äì Displays state and emits user Intents
		‚Ä¢ Intent ‚Äì User interactions or events
		‚Ä¢ Reducer ‚Äì Transforms old state + intent into new state

	‚û§ Flow:
		1. View emits an Intent.
		2. Intent goes to the ViewModel (or equivalent).
		3. ViewModel processes it ‚Üí outputs a new State.
		4. View is re-rendered based on new State.

	‚û§ Use Case:
		‚Ä¢ Complex UI with many user interactions
		‚Ä¢ Kotlin Coroutines + StateFlow/Flow
		‚Ä¢ Jetpack Compose / React / Flutter

	‚û§ Pros:
		‚Ä¢ Unidirectional data flow
		‚Ä¢ Immutable state ‚Äî easier to debug and test
		‚Ä¢ Predictable UI state at any point

	‚û§ Cons:
		‚Ä¢ Boilerplate (Intents, States, Reducers)
		‚Ä¢ Overhead for simple UIs
		‚Ä¢ Full re-rendering can be inefficient (if not optimized)

4. üß± VIPER (View-Interactor-Presenter-Entity-Router)
	‚û§ Analogy:
		Like an organization:
			‚Ä¢ View is the intern (just displays info),
			‚Ä¢ Presenter is the manager (talks to departments),
			‚Ä¢ Interactor is the worker (does business logic),
			‚Ä¢ Entity is the knowledge base,
			‚Ä¢ Router handles navigation between departments.

	‚û§ Components:
		‚Ä¢ View ‚Äì Display UI and forward actions
		‚Ä¢ Interactor ‚Äì Handles business logic
		‚Ä¢ Presenter ‚Äì Prepares data for the View
		‚Ä¢ Entity ‚Äì Business model/data structure
		‚Ä¢ Router ‚Äì Handles navigation

	‚û§ Flow:
		1. View sends event to Presenter.
		2. Presenter forwards to Interactor.
		3. Interactor fetches/updates Entity.
		4. Presenter formats data and updates View.
		5. Router handles screen transitions.

	‚û§ Use Case:
		‚Ä¢ iOS development (popular in Swift/Objective-C)
		‚Ä¢ Clean architecture-style codebase
		‚Ä¢ When modularization is a priority

	‚û§ Pros:
		‚Ä¢ Very testable (clean separation)
		‚Ä¢ Modular and scalable
		‚Ä¢ Clear responsibility

	‚û§ Cons:
		‚Ä¢ Too much boilerplate
		‚Ä¢ Slower to develop
		‚Ä¢ Overkill for small projects