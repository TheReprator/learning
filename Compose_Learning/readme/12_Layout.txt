ğŸ§© What is Layout()?
    ğŸ§  Definition:
            Layout() is a low-level composable in Jetpack Compose that gives you full control over how to measure and
            place child composables.

            Think of it as:
                "I want to control the layouting logic from scratchâ€”Compose, don't interfere."

            â€¢ It's the building block behind high-level layout composables like Row, Column, Box, etc.
            â€¢ A very important feature of the Layout phase is the single pass measurement. This means that a layout
              element may not measure any of its children more than once. Single-pass measurement is good for performance, allowing Compose to efficiently handle deep UI trees.


    ğŸ” Lifecycle:
        â€¢ Composition: The Layout composable and its children are composed.
        â€¢ Measurement: measurePolicy.measure() is invoked with constraints and child measurables.
        â€¢ Placement: Each child is placed manually.

    LifeCycle Diagram:
        ./pictures/order_of_compose_phases.png

    ğŸ”§ MeasurePolicy Breakdown
            MeasurePolicy { measurables, constraints ->
                // 1. Measure children
                // 2. Determine own size
                // 3. Place children
                layout(width, height) {
                    // child.place(x, y)
                }
            }

            Terminology:
                â€¢ measurables: List of children to measure.
                â€¢ constraints: Min/max bounds that you must respect.
                â€¢ placeables: Result of measuring each child.
                â€¢ layout(): Defines size of this layout and logic for placing children.

    âœ… Example
                @Composable
                fun MyRow(
                    modifier: Modifier = Modifier,
                    content: @Composable () -> Unit
                ) {
                    Layout(
                        content = content,
                        modifier = modifier
                    ) { measurables, constraints ->

                        // Step 1: Measure all children with same constraints
                        val placeables = measurables.map { measurable ->
                            measurable.measure(constraints)
                        }

                        // Step 2: Calculate total width and max height
                        val width = placeables.sumOf { it.width }
                        val height = placeables.maxOfOrNull { it.height } ?: 0

                        // Step 3: Define size and place children
                        layout(width, height) {
                            var xOffset = 0
                            placeables.forEach { placeable ->
                                placeable.placeRelative(x = xOffset, y = 0)
                                xOffset += placeable.width
                            }
                        }
                    }
                }

           Usage: This arranges the children horizontallyâ€”just like a Row.

                MyRow {
                    Text("One")
                    Text("Two")
                    Text("Three")
                }

âœ… 2. .layout {} â€” Modifier
        ğŸ”§ Purpose:
                Modify how a single child composable is measured and placed, via its modifier chain.

        ğŸ“¦ API Signature:
                fun Modifier.layout(
                    measure: (Measurable, Constraints) -> MeasureResult
                ): Modifier

        ğŸ“Œ When to Use:
                â€¢ You want to override layout behavior of a single composable.
                â€¢ You want to tweak its position (like shifting, scaling, changing size).
                â€¢ You want to adjust measurement or placement from the outside (not create a new container).

        ğŸ” Lifecycle:
                â€¢ Applied after composition, during layout phase.
                â€¢ Called when layout changes (size, constraints, etc.).
                â€¢ Doesn't affect composition.

        ğŸ§© Example:
                Box(
                    modifier = Modifier
                        .background(Color.LightGray)
                        .size(200.dp)
                ) {
                    Box(
                        modifier = Modifier
                            .size(50.dp)
                            .background(Color.Red)
                            .layout { measurable, constraints ->
                                val placeable = measurable.measure(constraints)
                                layout(placeable.width, placeable.height) {
                                    // Custom placement: offset child by 30px on x and y
                                    placeable.place(30, 30)
                                }
                            }
                    )
                }

ğŸš§ 1. What is SubcomposeLayout?
       ğŸ§  Definition:
                SubcomposeLayout is a powerful low-level composable that allows you to defer the composition of children
                until after you know certain constraints or sizes.

                âœ… Description:
                    â€¢ Special Composable that composes children on-demand during measurement.
                    â€¢ Children can depend on the size or layout result of others.

       ğŸ§ªAnalogy
                Think of SubcomposeLayout like a chef who doesn't prepare all dishes upfront. Instead, the chef waits to
                see what size of plate you give him (constraints), and then decides what and how much to cook
                (compose) based on it.

                Whereas in Layout(), the chef already has the full dish ready â€” you just cut and arrange it on the
                plate (measure/place only).

       ğŸŒ€Lifecycle of SubcomposeLayout
            Hereâ€™s the simplified lifecycle:
                â€¢ Initial Composition â€” The SubcomposeLayout is composed in the UI tree.
                â€¢ Measurement begins.
                â€¢ During measurement, it calls subcompose(slotId) { content }, which triggers actual composition of child
                    content.
                â€¢ Each subcompose(...) returns Measurable list.
                â€¢ You measure those measurables with given constraints.
                â€¢ You place them using standard layout(width, height).

            LifeCycle Diagram:
                    ./pictures/order_of_sub_compose_phases.png

       ğŸ› ï¸Syntax & Example
                @Composable
                fun MySubcomposeLayout() {
                    SubcomposeLayout { constraints ->

                        val topMeasurables = subcompose("top") {
                            Text("I'm at the top")
                        }

                        val topPlaceables = topMeasurables.map { it.measure(constraints) }
                        val topHeight = topPlaceables.maxOf { it.height }

                        val bottomMeasurables = subcompose("bottom") {
                            Text("I'm below top")
                        }
                        val bottomPlaceables = bottomMeasurables.map { it.measure(constraints) }

                        val totalHeight = topHeight + bottomPlaceables.maxOf { it.height }

                        layout(constraints.maxWidth, totalHeight) {
                            var y = 0
                            topPlaceables.forEach {
                                it.placeRelative(0, y)
                                y += it.height
                            }

                            bottomPlaceables.forEach {
                                it.placeRelative(0, y)
                            }
                        }
                    }
                }
             Usage: This arranges the children verticallyâ€”just like a column.

       ğŸ§°Use Cases
            Use Case	                    Why SubcomposeLayout Helps
            ğŸ”€ Lazy Lists	                Items are composed only when they appear (e.g., LazyColumn uses this internally).
            ğŸ“ Dynamic Overlays	            Compose a tooltip based on size of an anchor.
            ğŸ§© Dependent Composition	    Compose a child only after knowing another childâ€™s size.
            âš ï¸ Constraints-Dependent UI	    Child layout depends on runtime constraints.

       ğŸ§µReal-World Example
                Scenario: You want to show a tooltip only after measuring the size of a Button.
                âœ… With SubcomposeLayout, you can:
                        â€¢ First compose and measure the button.
                        â€¢ Then based on its size, compose a tooltip at a correct offset.

ğŸ†š Comparison Table
    Feature	                    .layout {}(Modifier)	    Layout {}(Composable)	        SubcomposeLayou(Composable)
    Level	                    Modifier	                Composable	                    Composable
    Compose children manually	âŒ	                        âœ… (composed already)	        âœ… (composed during measure)
    Measure + Place control	    âœ…	                        âœ…	                            âœ…
    Compose based on size	    âŒ	                        âŒ	                            âœ…
    Reusability	                Modifier level	            Reusable layout logic	        Fully custom & powerful layout engine
    Use cases	                Simple offset, padding,     Row, Column, custom layout      LazyColumn, Tooltip, Carousel etc
                                custom drawing
    Children Composed During    Composition                 Composition                     Measurement phase (on-demand)


ğŸ“Œ What Are Intrinsics in Jetpack Compose?
            Intrinsics refer to the minimum or maximum size a Composable would like to be along an axis, without knowing
            the exact constraints yet. Think of it as asking:

                â€¢ ğŸ“ â€œHey child, how wide would you ideally want to be to show all your content?â€
                â€¢ ğŸ“ â€œAnd if I gave you this width, how tall would you need to be?â€

        ğŸ§¬ Lifecycle of Intrinsic Measurements
            Intrinsics in Layout Flow:
                â€¢ Parent wants to size itself based on children.
                â€¢ Parent calls intrinsic functions like minIntrinsicWidth or maxIntrinsicHeight on children.
                â€¢ Children do not get measured at this point; they only report their preferred dimensions.
                â€¢ Later, during actual measurement, measure() is called with concrete constraints.

            Important:
                â€¢ Intrinsic measurements do not cache.
                â€¢ They may trigger recomposition or recalculation.
                â€¢ They can be expensive, especially with complex Composables.

        ğŸ”¢ Types of Intrinsics in Compose
            Each Composable has these four methods available for intrinsic size:

            Function Name	Description
                â€¢ minIntrinsicWidth(h)	Minimum width child wants for height h
                â€¢ maxIntrinsicWidth(h)	Maximum width child can use for height h
                â€¢ minIntrinsicHeight(w)	Minimum height child wants for width w
                â€¢ maxIntrinsicHeight(w)	Maximum height child can use for width w

        âš ï¸ Performance Implications
                â€¢ Intrinsics can be costly, because they may trigger multiple measurements.
                â€¢ Jetpack Compose discourages overuse of IntrinsicSize.Min/Max, and they are not always supported in
                    LazyLayouts (like LazyColumn).
                â€¢ Prefer normal measurement (Modifier.fillMax..., .wrapContentSize(), etc.) unless precise alignment
                    is required.

        âœ… Real-world Example
            Problem:
                    You want to align multiple Text composables in different rows with the same minimum width.
            Example:
                    Row(Modifier.height(IntrinsicSize.Min)) {
                        Column(
                            Modifier
                                .weight(1f)
                                .fillMaxHeight()
                                .background(Color.Gray)
                        ) {
                            Text("Short")
                        }

                        Column(
                            Modifier
                                .weight(1f)
                                .fillMaxHeight()
                                .background(Color.LightGray)
                        ) {
                            Text("This is a really long line of text.")
                        }
                    }
            Usage:
                    ğŸŸ¡ The row uses IntrinsicSize.Min for height, so both columns are tall enough to fit their tallest
                    child.

âš”ï¸ SubcomposeLayout vs Intrinsics
        ğŸ› ï¸At first glance, SubcomposeLayout and intrinsics might appear to solve similar problems: both are used when
        you want to measure one child based on another. But their philosophy, performance characteristics, and use cases
        differ significantly.

    ğŸ†š Comparison Table
        Criteria	    Intrinsics	                                    SubcomposeLayout
        ğŸ” Goal	        Ask child for preferred                         Measure/render some content only after
                        size before measuring	                        knowing something else

        ğŸ§  Idea	        â€œTell me how big you want to beâ€	            â€œIâ€™ll render content B only after measuring content Aâ€

        ğŸ“¦ Used In	    Precise sizing/alignment (text, forms)	        Complex conditional/dynamic layouts (tab indicators,
                                                                        tooltips)
        ğŸ”„ Phase	    Happens before measurement phase	            Composable is deferred until first measure completes
        ğŸš« Limitation	Cannot access Composableâ€™s content or           Can fully compose, measure, and layout content blocks
                        structure
        ğŸ¢ Performance	May be expensive: recomposes to compute size	Slightly better in some casesâ€”composition is deferred,
                                                                        not repeated
        âœ… Best When	Layouts with known structure,                   Layouts with conditional or dependent Composables
                        needing alignment

ğŸ§  Analogy
    Intrinsics:
            Like asking someone how much space they want, and arranging furniture based on that without seeing the
            furniture.
    SubcomposeLayout:
            Like seeing the actual furniture, measuring it in the room, and then deciding where to put another chair
            based on it.


References:
    https://www.youtube.com/watch?v=l6rAoph5UgI&t=471s&ab_channel=AndroidDevelopers