üîÅ produceState:
      a)It is a Composable API that lets you create Compose State objects by running coroutines inside it.
        It‚Äôs ideal when you want to:
            ‚Ä¢ Run a suspending function
            ‚Ä¢ Emit its result as Compose state
            ‚Ä¢ Automatically cancel and restart when inputs (keys) change

      b)üîç Basic Syntax
            @Composable
            fun MyComposable(id: String) {
                val data by produceState(initialValue = null, id) {
                    // Coroutine scope here
                    value = loadData(id) // suspending function
                }

                Text(text = data ?: "Loading...")
            }

          ‚Ä¢ initialValue is the starting state
          ‚Ä¢ value = ... sets the state and triggers recomposition
          ‚Ä¢ The block runs in a coroutine, automatically managed by Compose

      b)üîë Key Features
        Feature	                    Description
        Suspending work	            Runs inside coroutine scope
        Emits state	                Updates Compose state with value = ...
        Lifecycle-aware	            Automatically cancels if the composable leaves composition
        Reacts to key changes	    Automatically cancel and restarts if any of the keys change

      c)‚öôÔ∏è How It Works Internally
            ‚Ä¢ Under the hood, Compose:
                    ‚Ä¢ Creates a MutableState with initialValue
                    ‚Ä¢ Launches a coroutine
                    ‚Ä¢ Runs your code block
                    ‚Ä¢ Cancels and restarts it if any of the keys (like userId) change
                    ‚Ä¢ Re-renders the UI when value changes

      d)‚úÖ Real-World Example: Fetching from Network
                @Composable
                fun UserProfile(userId: String) {
                    val user by produceState<User?>(initialValue = null, userId) {
                        value = fetchUserFromApi(userId) // suspending call
                    }

                    if (user == null) {
                        Text("Loading...")
                    } else {
                        Text("Hello, ${user.name}")
                    }
                }
            ‚Ä¢ Automatically fetches new user data when userId changes.
            ‚Ä¢ produceState holds and exposes the result as a Compose state.

      e) üîÅ Example With Flow
                1) You can collect a flow using produceState:
                    @Composable
                    fun Timer(): State<Int> {
                        return produceState(initialValue = 0) {
                            tickerFlow(1000L).collect {
                                value = it
                            }
                        }
                    }
                1) Or use it directly in a Composable:
                    @Composable
                    fun TimerText() {
                        val count by produceState(initialValue = 0) {
                            tickerFlow(1000L).collect {
                                value = it
                            }
                        }

                        Text("Time: $count")
                    }

      f)‚ö†Ô∏è Caveats
            ‚Ä¢ Don‚Äôt use produceState if you don‚Äôt need to emit state ‚Äî use LaunchedEffect instead.
            ‚Ä¢ If your state comes from ViewModel, prefer observing with collectAsState().


üîÅ derivedStateOf:
    a) üß† What is derivedStateOf?
            ‚Ä¢ It is used to create a value that depends on other state values, and it updates only when those values
              change.
            ‚Ä¢ It's like a selector or a computed property ‚Äî very useful for optimizing recomposition.

    b)üîß Basic Syntax
               val derivedState = remember {
                   derivedStateOf {
                       computeSomething(stateA, stateB)
                   }
               }

             ‚Ä¢ derivedStateOf only recomputes when inputs used inside the block change
             ‚Ä¢ It avoids recomposition if the result hasn‚Äôt changed (thanks to equals() check)
             ‚Ä¢ Must be used inside remember to persist between recompositions

    b)üîß Example
                @Composable
                fun DerivedStateExample() {
                    var name by remember { mutableStateOf("") }

                    val isNameLong by remember {
                        derivedStateOf { name.length > 10 }
                    }

                    Column {
                        TextField(value = name, onValueChange = { name = it })
                        if (isNameLong) {
                            Text("That's a long name!")
                        }
                    }
                }
            ‚Ä¢ isNameLong will only recompute when name changes
            ‚Ä¢ It won‚Äôt trigger recomposition if the name.length > 10 result remains the same

    c)‚ö° Why Use derivedStateOf?
        ‚úÖ To avoid unnecessary recomposition.
            If you derive a value from another state and it's expensive to compute or affects recomposition, wrap it in
            derivedStateOf.

        üìâ Without derivedStateOf
                val isValid = name.length > 10

            ‚Ä¢ This gets recomputed every time the composable recomposes.
            ‚Ä¢ Even if isValid is unchanged, dependent UI might still recompose.

        üìà With derivedStateOf
                val isValid by remember { derivedStateOf { name.length > 10 } }

            ‚Ä¢ Recomputed only when name changes
            ‚Ä¢ Triggers recomposition only if result of name.length > 10 changes

    e)‚ùå Incorrect usage of derivedStateOf
           1)‚ùåUsing derivedStateOf without remember
                val isValid = derivedStateOf { name.length > 5 }
                    ‚Ä¢ This creates a new derived state object every recomposition, defeating the purpose.
                    ‚Ä¢ derivedStateOf must be wrapped in remember to preserve the result between recompositions.
                ‚úÖ Correct:
                    val isValid by remember { derivedStateOf { name.length > 5 } }
           2)‚ùåWrapping a simple value that doesn‚Äôt need memoization
                val textLength by remember {
                    derivedStateOf { text.length }
                }
                    ‚Ä¢ If the computation is cheap, derivedStateOf is overkill.
                    ‚Ä¢ It‚Äôs useful for expensive operations or where recompositions need to be optimized.
                ‚úÖ Correct:
                    val textLength = text.length

           3)‚ùåModifying state inside derivedStateOf
                    val flag by remember {
                        derivedStateOf {
                            someState = computeSomething() // ‚ùå NEVER mutate state here
                            someState
                        }
                    }

                    ‚Ä¢ derivedStateOf is meant to read, not write.
                    ‚Ä¢ Changing state inside it can cause infinite recompositions or bugs.

                 ‚úÖ Correct:
                       val flag by remember {
                           derivedStateOf { someState > 5 }
                       }

            4)‚ùåNot depending on any actual state inside
                    val result by remember {
                        derivedStateOf {
                            expensiveFunction() // ‚ùå Not based on any state
                        }
                    }

                    ‚Ä¢ If there's no Compose state used in the block, derivedStateOf is useless here.
                    ‚Ä¢ It won‚Äôt recompute because it doesn‚Äôt know what to watch.

                   ‚úÖ Correct:
                             val result by remember(input) {
                                 derivedStateOf {
                                     expensiveFunction(input)
                                 }
                             }

üîÅ snapshotFlow:
        a)üì¶ What is snapshotFlow?
            ‚Ä¢ snapshotFlow converts Compose state into a cold Kotlin Flow.
            ‚Ä¢ It lets you observe Compose state changes in a Flow-based, reactive way ‚Äî perfect for side-effects or
              combining with other coroutine/Flow APIs.

        b)üß† In simple words:
            snapshotFlow watches a value inside a Composable and emits it as a Flow whenever that value changes.

        c)üîß Basic Syntax
                snapshotFlow {
                    someComposeState
                }
             ‚Ä¢ The block reads Compose state (like remember, mutableStateOf)
             ‚Ä¢ It creates a Flow that emits whenever the value changes
             ‚Ä¢ You can collect it like any other Flow

        d)‚úÖ Example: Observing Scroll Position
                    @Composable
                    fun ScrollObserverExample() {
                        val listState = rememberLazyListState()

                        LaunchedEffect(Unit) {
                            snapshotFlow { listState.firstVisibleItemIndex }
                                .collect { index ->
                                    Log.d("Scroll", "First visible item: $index")
                                }
                        }

                        LazyColumn(state = listState) {
                            items(100) { Text("Item $it") }
                        }
                    }
                ‚Ä¢ snapshotFlow tracks firstVisibleItemIndex
                ‚Ä¢ Emits a new value only when that index changes(If you scroll from item 0 ‚Üí 1 ‚Üí 2, it will emit: 0, 1, 2.)
                ‚Ä¢ Helps avoid unnecessary updates (only emits on real change, If you scroll and the index stays the same (like just a small
                    offset), it won‚Äôt emit again.)
