üß± Structure of a Custom Modifier
    A custom modifier typically consists of two main components:
        ‚Ä¢ Modifier Factory: An extension function on Modifier that provides a fluent API, enabling easy chaining of modifiers.
        ‚Ä¢ Modifier Element: Defines the actual behavior or effect of the modifier.

üîß Approaches to Creating Custom Modifiers
    1. Stateless Modifier Factory or Pure modifier factory (Non-Composable)
            üîπ Use when:
                ‚Ä¢ You‚Äôre just chaining existing modifiers
                ‚Ä¢ No need for state or runtime context
            ‚úÖ Pros:
                ‚Ä¢ Clean, reusable
                ‚Ä¢ Most readable and performant
            ‚ùå Cons:
                ‚Ä¢ No dynamic logic possible

            Example:
                fun Modifier.cardStyle() = this
                    .padding(8.dp)
                    .clip(RoundedCornerShape(12.dp))
                    .background(Color.White)

    2. custom modifier using CMF(composable modifier factory)

            üîπ Use when:
                ‚Ä¢ You need Compose runtime (e.g. remember, LaunchedEffect, animate*AsState)
                ‚Ä¢ Modifier depends on recomposable state
            ‚úÖ Pros:
                ‚Ä¢ Simple to write
                ‚Ä¢ Can use Compose APIs
            ‚ùå Cons:
                ‚Ä¢ Triggers recomposition
                ‚Ä¢ Not lifecycle-aware
                ‚Ä¢ Poor for performance-sensitive modifiers

            Example:
                    @Composable
                    fun Modifier.fade(enabled: Boolean): Modifier {
                        val alpha by animateFloatAsState(if (enabled) 0.5f else 1f)
                        return this.graphicsLayer { this.alpha = alpha }
                    }

    3. composed { }(Legacy Runtime Modifier)
            üîπ Use when:
                ‚Ä¢ You want state/Compose APIs inside a modifier chain
                ‚Ä¢ Still need remember, LaunchedEffect inside modifier logic
            ‚úÖ Pros:
                ‚Ä¢ Can use Compose runtime
                ‚Ä¢ Fine-grained logic inside modifiers
            ‚ùå Cons:
                ‚Ä¢ Deprecated for most cases
                ‚Ä¢ Slower, recreated on every recomposition
                ‚Ä¢ Not node-based (no lifecycle hooks)

            Example:
                fun Modifier.highlightOnFocus() = composed {
                    val isFocused = remember { mutableStateOf(false) }
                    this
                        .onFocusChanged { isFocused.value = it.isFocused }
                        .background(if (isFocused.value) Color.Yellow else Color.Transparent)
                }

    3. Modifier.Node / ModifierNodeElement (Recommended Modern Way)
                üîπ Use when:
                           ‚Ä¢ You need lifecycle hooks, custom layout, drawing, or event handling
                           ‚Ä¢ Want high performance and reuse
                ‚úÖ Pros:
                           ‚Ä¢ Most performant
                           ‚Ä¢ Lifecycle-aware (onAttach, onDetach), meaning the modifier can respond when it is added to or
                             removed from the composition tree.
                           ‚Ä¢ Doesn‚Äôt reallocate on recomposition
                ‚ùå Cons:
                           ‚Ä¢ More boilerplate to set up
                üß™ Example:
                               fun Modifier.fixedPadding(padding: Dp) = this then FixedPaddingElement(padding)

                               data class FixedPaddingElement(val padding: Dp) : ModifierNodeElement<MyPaddingNode>() {
                                   override fun create() = MyPaddingNode(padding)
                                   override fun update(node: MyPaddingNode) {
                                       node.padding = padding
                                   }
                               }

                               class MyPaddingNode(var padding: Dp) : Modifier.Node(), LayoutModifier {
                                   override fun MeasureScope.measure(measurable: Measurable, constraints: Constraints): MeasureResult {
                                       val pad = padding.roundToPx()
                                       val placeable = measurable.measure(constraints.offset(-pad * 2, -pad * 2))
                                       return layout(placeable.width + pad * 2, placeable.height + pad * 2) {
                                           placeable.place(pad, pad)
                                       }
                                   }
                               }

                üîç Problem: Modifier Nodes don‚Äôt automatically observe Compose state
                       When you use Modifier.Node, it does not recompose like a Composable function. This means if you try
                       to access a CompositionLocal (like LocalDensity, LocalLayoutDirection, or a custom one), changes to
                       it won‚Äôt automatically update the modifier.

                       For that you need to use CompositionLocalConsumerModifierNode, Implementing this interface allows
                       your Modifier.Node to read composition locals.

    üßæ Comparison Table(CMF vs Composed{})
            üîπ1. Extractability:
                    Example:
                        @Composable
                        fun Modifier.usingComposableFactory(): Modifier = ...

                        fun Modifier.usingComposed(): Modifier = composed {/***/}

                        // usingComposed can be used outisde the Composition scope
                        val extractedModifier = Modifier.usingComposed()

                        @Composable
                        fun MyComposable() {
                            ...
                            // we can only use usingComposableFactory() inside a @Composable scope
                            Text("Hello $it", modifier = extractedModifier.usingComposableFactory())
                        }
                    Explanation:
                        ‚Ä¢ when we create a CMF we can‚Äôt use it outside of the Composition scope since it‚Äôs annotated with
                          @Composable.
                        ‚Ä¢ On the contrary, this isn‚Äôt an issue with composed at all, as it doesn‚Äôt require @Composable
                          annotation, allowing for broader usage.

            üîπ2. Resolution Location of CompositionLocal Values:
                    Explanation:
                            When using CompositionLocals such as LocalContentColor, CMF and composed behave differently.

                                ‚Ä¢ CMF: CompositionLocals values are resolved at the call site(at run time) of the modifier
                                    factory.
                                ‚Ä¢ composed: CompositionLocals values are resolved at the usage site(at creation time) of
                                    the composed factory.

                    Example:
                            @Composable
                            fun Modifier.myCMFBackground(): Modifier {
                                val color = LocalContentColor.current
                                return background(color.copy(alpha = 0.5f))
                            }

                            fun Modifier.myComposedBackground(): Modifier = composed {
                                val color = LocalContentColor.current
                                background(color.copy(alpha = 0.5f))
                            }

                            @Composable
                            fun MyScreen() {
                                CompositionLocalProvider(LocalContentColor provides Color.Green) {
                                    // Background modifier created with green background
                                    val usingCMFModifier = Modifier.myCMFBackground().size(16.dp)
                                    val usingComposedModifier = Modifier.myComposedBackground().size(16.dp)

                                    // LocalContentColor updated to red
                                    CompositionLocalProvider(LocalContentColor provides Color.Red) {
                                         Row() {
                                            // Box will have green background, not red as expected.
                                            Box(modifier = usingCMFModifier)

                                            // Box has red background as expected.
                                            Box(modifier = usingComposedModifier)
                                        }
                                    }
                                }
                            }

            üîπ3. State Resolution:
                    Let‚Äôs say we have a custom Modifier that sets a random background and rotates the Layout when it‚Äôs
                    clicked. If we have 2 implementations using composed and CMF as following‚Ä¶

                    Example:
                            fun Modifier.rotateOnClick() = composed {
                                val color = remember { mutableStateOf(listOf(Color.Red, Color.Green).random()) }
                                var isClicked by remember { mutableStateOf(false) }
                                val rotation by animateFloatAsState(targetValue = if (isClicked) 45f else 0f)

                                background(color = color.value)
                                    .clickable { isClicked = !isClicked }
                                    .graphicsLayer { rotationZ = rotation }
                            }

                            @Composable
                            fun Modifier.rotateOnClick(): Modifier {
                               // same as rotateOnClick Using Composed...
                            }

                        üî∏ 1. Scenario:
                                @Composable
                                fun BoxesRow() {
                                    LazyRow {
                                        items(10) {
                                            Box(
                                                modifier = Modifier.rotateOnClick().size(100.dp),
                                            )
                                        }
                                    }
                                }

                                Output:
                                       This will work perfectly as expected. It‚Äôs not impressive I know :)
                                     Reference Image: ./pictures/result_cmf_vs_composed_good.gif

                        üî∏ 2. Scenario:
                                @Composable
                                fun BoxesRow() {
                                    val modifier = Modifier
                                        .rotateOnClick()
                                        .size(100.dp)
                                    LazyRow {
                                        items(10) {
                                            Box(
                                                modifier = modifier,
                                                contentAlignment = Alignment.Center,
                                            ) { ... }
                                        }
                                    }
                                }

                                Output:
                                    ‚Ä¢ CMF: all items are maintain their color as CMF resolves that state only once at the
                                          call site
                                    ‚Ä¢ composed: all items will be in red as composed resolves state at the usage site for
                                            each Layout
                                    Reference Image: ./pictures/result_cmf_vs_composed_bad.gif

            üîπ4. Performance:
                   ‚Ä¢ composed: It performs poorly as it usage "materialize()", which is pretty expensive because even a
                                simple modifier will utilize a lot of other modifiers/states, and flatting out all of
                                that impacts the performance and potentially creates redundant copies of Modifier.Elements.

                                    That would be a total of‚Ä¶
                                        - 13 Modifier.composed calls
                                        - 34 remember calls
                                        - 11 Side Effects
                                        - 16 Leaf Modifier.Elements
                   ‚Ä¢ CMF: On the other hand, CMF does not use the materialize() function which reduces the performance overhead.

            üîπ5. Skippablity:
                    Sadly both approaches are not skippable ü•≤

                   ‚Ä¢ composed: Since modifiers using composed aren‚Äôt @Composables themselves, the Compose Compiler can‚Äôt
                                cache the lambda. That means that the resulting Modifier will never compare equals with
                                 the previous one, making it a non-skippable modifier.
                   ‚Ä¢ CMF: It is never skipped because composable functions that have return values cannot be skipped.

Reference:
    https://engineering.teknasyon.com/composable-modifier-vs-composed-factory-in-jetpack-compose-6cbb675b0e7b
    https://proandroiddev.com/custom-modifiers-in-jetpack-compose-a950e6f9eb72
    https://developer.android.com/develop/ui/compose/custom-modifiers