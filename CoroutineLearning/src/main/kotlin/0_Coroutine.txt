‚úÖ What is a Coroutine?

    Kotlin Coroutines are a design pattern for simplifying code that allows you to write asynchronous and non-blocking
    code in a sequential way. This makes your code easier to read, write, and maintain.

    In simpler terms:
        A coroutine is like a thread, but much cheaper and more cooperative.

‚úÖ Advantages of Coroutines
    Lightweight
        ‚Ä¢ Thousands of coroutines can run on a few threads.
        ‚Ä¢ Unlike threads, they don‚Äôt require OS-level stack or scheduling.
    Structured Concurrency
        ‚Ä¢ Helps manage the lifecycle of async tasks ‚Äî a parent coroutine cancels its children automatically.
    Readable Asynchronous Code
        ‚Ä¢ Looks like synchronous code (no nested callbacks or messy chains).
    Better Resource Efficiency
        ‚Ä¢ Uses suspending functions, not blocking calls.
    Built-in Cancellation
        ‚Ä¢ Easy and safe cancellation of ongoing tasks (e.g., API calls, animations).

‚ùå Disadvantages of Coroutines
    Learning Curve
        ‚Ä¢ Understanding scopes, dispatchers, structured concurrency, exception handling takes effort.
    Debugging is Harder
        ‚Ä¢ Stack traces and step-through debugging can be less intuitive compared to threads.
    Improper Usage Can Lead to Bugs
        ‚Ä¢ Launching coroutines in the wrong scope or dispatcher can cause memory leaks or UI issues.
    Not Always Faster
        ‚Ä¢ For CPU-intensive tasks, coroutines offer no performance gain over threads.


üß† Threads vs Processes vs Coroutines (Detailed)
    Feature	            Process	                                Thread	                                Coroutine
    Definition	        Independent execution unit with its     Sub-unit of process sharing memory      Lightweight task within a thread
                        own memory space

    Memory	            Each process has its own memory	        Shares memory with sibling threads	    Shares memory with parent thread

    Context Switch	    Heavy ‚Äî managed by OS	                Medium ‚Äî managed by OS	                Light ‚Äî managed by Kotlin runtime

    Crash Impact	    One process crash doesn‚Äôt affect        Crash may affect the whole process      Crash in one coroutine can be isolated
                        others		                                                                    via SupervisorJob

    Concurrency	        True parallelism	                    True parallelism	                    Pseudo-concurrent (based on suspend/resume)

    Use Case	        Browser tabs, sandboxed systems	        Multi-core processing	                Async I/O, background work in UI apps

    Startup Cost	    High	                                Medium	                                Low

    Communication	    Inter-process communication (IPC)	    Shared memory or sync primitives	    Shared memory within coroutine scope