Securing Android Application:
        üìå 1) Protecting Your App from Reverse Engineering & Debugging
                ‚Ä¢ Anti-Developer-Options: Check developer is enabled or not
                ‚Ä¢ Anti-Debugging: Detect debuggers at runtime
                ‚Ä¢ Anti-Root Detection: The key to most attack starts with obtaining privileged access as an admin or root user. Therefore, we must protect our 
                                       application by implementing root detection
                ‚Ä¢ Obfuscation: It is basically a process to change the name of file, variable to some random, to make to it difficult for reverse decoding or decompilation.
                               Android offers open-source obfuscation tools such as ProGuard and R8, as well as more advanced paid options like DexGuard
                ‚Ä¢ Anti-Tampering: 
                                 ‚Ä¢ Google Play Integrity API: It helps you check that interactions and server requests are coming from your genuine app binary running 
                                                             on a genuine Android device. 

                                        ‚Ä¢ Genuine app binary: Determine whether you're interacting with your unmodified binary that Google Play recognizes.
                                        ‚Ä¢ Genuine Play install: Determine whether the current user account is licensed, which means that the user installed or paid for 
                                                                your app or game on Google Play.
                                        ‚Ä¢ Genuine Android device: Determine whether your app is running on a genuine Play Protect certified Android-powered device 
                                                        (or a genuine instance of Google Play Games for PC).

                                 ‚Ä¢ APK Signature Verification: 
                                                        ‚Ä¢ It ensures that an app hasn't been tampered with. The process involves using the Android Open Source 
                                                          Project's APK signature scheme to verify the APK's integrity, including resources, code, and ZIP metadata. 

                                                        ‚Ä¢ Any modification to the APK, including ZIP metadata, invalidates the signature, preventing installation or operation 
                                                          of the tampered app. 

                                                        ‚Ä¢ It is recommended to perform this check on a remote server by sending the current certificate signature 
                                                           and comparing it on the server side.

                                ‚Ä¢ useEmbeddedDex: It is used to control how dex files are loaded in an app, particularly for apps that use custom class loading (such as 
                                                  plugin frameworks, multi-process apps, or dynamic feature loading).
                                                                It tells the Android system: "Do not optimize or transform dex files for this app. Keep them in raw .dex 
                                                  format inside the APK."


                                                üîπ What Problem Does It Solve?
                                                        By default, starting from Android 8.0 (API level 26), the Android runtime uses a mechanism called dex compression and optimization, such as CompactDex and other performance-focused formats, to optimize dex loading.

                                                        This is great for performance, but it breaks custom class loading scenarios where apps expect to load .dex files directly from APK assets or external locations ‚Äî because the dex files might not be stored in their raw, expected format anymore.

                                                ‚ö†Ô∏è Downsides
                                                        ‚Ä¢ Performance impact: Dex files are not optimized (no OAT/ART pre-compilation).
                                                        ‚Ä¢ Increased memory usage and slower startup due to lack of optimizations.

                                                ‚úÖ Use it only when you rely on manual dex/class loading, and are targeting Android 8.0+ where the default dex optimizations might break your logic and will be applicable from android 10(Api 29) and above.

                                                üîÅ How to use it:

                                                        // In the application element of the app's manifest file
                                                        android::useEmbeddedDex = true

                                                        // In the module-level build.gradle.kts file (or build.gradle file if using Groovy)
                                                        packagingOptions {
                                                                dex {
                                                                        useLegacyPackaging = false
                                                                }
                                                        }

                üìå 2) Securing Execution Environment
                        ‚Ä¢ Anti-Emulation: It is a techniques aim to prevent malware or protected applications from being reverse-engineered, debugged, or otherwise analyzed 
                                          by unauthorized parties often by using emulators or sandboxes.

                                          So here, we check for emulation like, the app should not be running on emulator, simulator or sandboxes or custom phone
                        ‚Ä¢ Anti-Sideloading: Restrict APK installation from untrusted sources, we recommand to download the application from Google play by checking the 
                                            vendor application.

                        ‚Ä¢ Anti-Multiwindow: Prevent multi-window mode to avoid overlay attacks, if it is possible, as we are en era of foldables and adaptive

                üìå 3)  Preventing Data Leakage & Unauthorized Access
                        ‚Ä¢ Log Protection: Avoid logging data in Prod
                        ‚Ä¢ Secure Database & Preference: We can use SQLCipher for encrypted database storage or save encrypted data directly in your 
                                DB and EncryptedSharedPreferences for shared Preference
                        ‚Ä¢ Secure Binding Services: 
                                        ‚Ä¢ set exported to false in manifest to respective android components, if we do not want to share anything with external vendors
                                        ‚Ä¢ Take care of binding flag, when using services or AIDL

                        ‚Ä¢ Anti-Screenshot & Overlay Detection:
                                        Use FLAG_SECURE to block screenshots and to block overlays using this flag permission android.permission.HIDE_OVERLAY_WINDOWS(introduced in Android 12). For oldest Android version, we can implement a custom solution to inject event in random touch and intercept it

                        ‚Ä¢ Anti-Camera & Microphone Abuse: Restrict background access using Android 10+ APIs and put some mechanism detection when camera is open and used 
                                        by another threat application

                        ‚Ä¢ Anti-Accessibility Exploits: Stop accessibilty for views that contain sensitive information like balace, CVV, Account No. etc.

                üìå 4) Strengthening Authentication & Secure Communication
                        ‚Ä¢ Biometric Authentication: Biometric API exist for strong user authentication like fingerprint, face, or iris which be used to verify the identity of 
                                                the user before doing any transaction.

                        ‚Ä¢ Secure Connection (TLS/SSL)

                        ‚Ä¢ HTTPS/SSL Security: To prevent Man-in-the-Middle (MITM) attacks, Android 7 (API 24) introduced the Network Security Config
                        ‚Ä¢ API Key Protection: 
                                ‚Ä¢ Gradle Properties or enviorment variables, and make sure that is not part of git commit
                                ‚Ä¢ Use NDK to store API-KEY inside a ‚Äú.cpp‚Äù file.

                üìå 5) Secure Cryptography & Key Management
                        ‚Ä¢ Secure Cryptography: 
                        ‚Ä¢ Key Rotation: Programming security is time-sensitive, and in this context, cryptographic keys must be regularly updated to mitigate potential risks. 
                                It is recommended not to exceed a 90-day lifespan for secure keys to ensure optimal protection.
                        ‚Ä¢ Use Secure Random: 

                üìå 6) Enhancing System Security & Updates
                        ‚Ä¢ Secure Elements & TEE (Trusted Execution Environment): As said in the last point, Android Keystore should be generated on Trusted Execution 
                           Environment (TEE) storage backed in StrongBox introduced in Android 9 (for lowest version, we can use software white box but it‚Äôs must be respect the security standard).

                        ‚Ä¢ GMS Security Updates: Google provides GMS (Google Mobile Services), which checks for any security updates. To verify this, we should check 
                                the currently installed version of Google Play Services

                        ‚Ä¢ Backup Security:
                                In Android, to retrieve your preferences after reinstalling an application, we use the backup mechanism. However, this represents a security issue, which is why it has been deprecated starting from Android 12 and may be removed in future versions. We recommend disabling auto-backups for sensitive data by setting android:allowBackup="false"

                        ‚Ä¢ CVE Patching & Dependency Updates:
                                In Android, we have a higher probability to use third party library which can represent a vulenrability risk, so before integrating any library, we must check the origin , the maintainers community, the latest support date .. and after that we should regularly update and check for CVEs and finally use only Stable version.

                üìå 7) Advanced Security Techniques
                        ‚Ä¢ Secure OpenGL: When using OpenGl, use the flag "EGL_PROTECTED_CONTENT_EXT" to protect rendering data to be read illegaly from the RAM memory
                        ‚Ä¢ Multiprocess Security: Try to run the service or Android component in a separte process via manifest, This helps to prevent unauthorized access
                                 by ensuring that each process operates in a separate environment, making it more difficult for one process to access the memory or data of another


‚ùìKeystore Security: You‚Äôre storing a cryptographic key via Android Keystore. Walk me through how to prevent downgrade or extraction attacks in rooted devices.

        üß± 1. Use Hardware-Backed Keystore
                ‚Ä¢ Always request a hardware-backed key (TEE(Trusted execution enviorment) or StrongBox) when generating:
                   Code:
                        val keyGenSpec = KeyGenParameterSpec.Builder("secure_key_alias",PURPOSE_ENCRYPT or PURPOSE_DECRYPT)
                        .setUserAuthenticationRequired(true)
                        .setBlockModes(BLOCK_MODE_GCM)
                        .setEncryptionPaddings(ENCRYPTION_PADDING_NONE)
                        .setIsStrongBoxBacked(true) // Fallback if unavailable
                        .build()
                ‚Ä¢ If StrongBox is not available, log and limit functionality (e.g., disable high-risk actions).

        üõ°Ô∏è 2. Prevent Downgrade Attacks
                ‚úÖ a. Version Pinning
                        ‚Ä¢ Tie key generation to app version code or key schema version:
                           Code:
                                val versionKeyAlias = "secure_key_v$BUILD_VERSION"

                        ‚Ä¢ If the current installed version is lower than the last-used version, deny access to the key.

                ‚úÖ b. Key Attestation via SafetyNet / Play Integrity API
                        ‚Ä¢ Use device attestation to verify:
                                ‚Ä¢ Bootloader is locked
                                ‚Ä¢ OS is verified
                                ‚Ä¢ Hardware is unmodified
                        ‚Ä¢ Reject key usage if device fails integrity check.

                                ‚ùìTo check if the device‚Äôs bootloader is locked, OS is verified, and hardware is unmodified, you must use Android‚Äôs attestation APIs,
                                  specifically:
                                        ‚úÖ 1. Use Play Integrity API (Modern) ‚Äî Recommended
                                                Google recommends replacing SafetyNet with Play Integrity API, especially post-2024.
                                                üîß Setup:
                                                        1. Integrate the Play Integrity API into your app via Play Console.
                                                        2. Request device integrity from Google servers.
                                                        3. Parse the returned integrity verdict JSON.
                                                ‚úÖ Integrity Verdict Example:
                                                        {
                                                                "deviceIntegrity": {
                                                                        "deviceRecognitionVerdict": ["MEETS_DEVICE_INTEGRITY"]
                                                                }
                                                        }

                                                | Verdict                  | What It Tells You                                          |
                                                | ------------------------ | -------------------------------------------------------    |
                                                | `MEETS_DEVICE_INTEGRITY` | ‚úÖ Bootloader locked, OS verified, no tampering detected   |
                                                | `MEETS_BASIC_INTEGRITY`  | ‚ö†Ô∏è Bootloader might be unlocked or uncertified ROM         |
                                                | `MEETS_STRONG_INTEGRITY` | ‚úÖ Verified OS + hardware + Play-certified + not rooted    |
                                                | `NO_INTEGRITY`           | ‚ùå Rooted/emulated device or tampered environment          |

                                        ‚úÖ 2. (Legacy) Use SafetyNet Attestation API (deprecated)
                                                Setup:
                                                        1. Call SafetyNet.getClient(context).attest(nonce, apiKey)
                                                        2. Send response JWS to Google
                                                        3. Decode payload using Base64.decode() and parse
                                                Check fields:
                                                        ‚Ä¢ ctsProfileMatch: ‚úÖ ‚Üí OS is verified
                                                        ‚Ä¢ basicIntegrity: ‚úÖ ‚Üí Bootloader locked / not tampered
                                                        ‚Ä¢ advice: "LOCK_BOOTLOADER" or other ‚Üí indicates a rooted/unlocked device


                                        ‚úÖ 3. (Advanced) Use Key Attestation with Keystore
                                                If you're generating a cryptographic key, you can request an attestation certificate:
                                                  Code:
                                                        val spec = KeyGenParameterSpec.Builder("key_alias", PURPOSE_SIGN)
                                                                        .setAttestationChallenge(nonce)
                                                                        .setUserAuthenticationRequired(true)
                                                                        .build()
                                                        Then extract:
                                                                ‚Ä¢ Verified boot state (VerifiedBootState)
                                                                ‚Ä¢ Bootloader state (Locked/Unlocked)
                                                                ‚Ä¢ OS version and patch level
                                                Attestation Extension Fields (X.509 certificate extension):
                                                        Field                           Description
                                                        verifiedBootState               "Verified" = OS was verified
                                                        deviceLocked                    true = Bootloader is locked
                                                        attestationSecurityLevel        "TEE" or "StrongBox"

                                                Parse using X509Certificate.getExtensionValue(...)

                ‚úÖ c. Prevent App Downgrade via android:versionCode enforcement
                        ‚Ä¢ Set android:versionCode with android:extractNativeLibs="false" and disallow install on lower version via backend checks.
                        ‚Ä¢ For critical apps, enable Play App Signing + rollback protection

        üîê 3. Mitigate Extraction on Rooted Devices
                ‚úÖ a. Enforce setUserAuthenticationRequired(true)
                        ‚Ä¢ Require biometric auth before key use.
                        ‚Ä¢ Enforce timeout (setUserAuthenticationValidityDurationSeconds)

                ‚úÖ b. Add setInvalidatedByBiometricEnrollment(true)
                        ‚Ä¢ Prevent continued use of keys after biometric change (e.g., attacker adds their fingerprint).

                ‚úÖ c. Tamper Checks
                        ‚Ä¢ Detect root with tools like:
                        ‚Ä¢ SafetyNet or Play Integrity
                        ‚Ä¢ Custom checks (su binary, /system/xbin, etc.)
                        ‚Ä¢ AppShielding/Obfuscation (e.g., DexGuard, R8, or proprietary solutions)

                ‚úÖ d. Obfuscate Key Alias Names & Paths
                        ‚Ä¢ Use random, non-predictable key aliases.
                        ‚Ä¢ Keep alias and usage in obfuscated code paths.


        üß† 4. Bonus: Key Lifecycle Strategy
                ‚Ä¢ Rotate keys every X months (backend-coordinated).
                ‚Ä¢ Use an encrypted wrapper: encrypt sensitive data using an AES key from Keystore, and then rotate that wrapper key if compromised.


‚ùìWhat alternatives do you use when iOS has hardware-backed secure enclave, but Android doesn‚Äôt?
        üß© Step-by-Step Deep Dive
                üîπ 1. Detect Secure Hardware Capability on Android
                        ‚Ä¢ Use KeyInfo and KeyStore.getInstance("AndroidKeyStore"):
                           Code:
                                val factory = KeyFactory.getInstance(key.algorithm, "AndroidKeyStore")
                                val keyInfo = factory.getKeySpec(key, KeyInfo::class.java) as KeyInfo
                                val isHardwareBacked = keyInfo.isInsideSecureHardware

                        ‚Ä¢ If isInsideSecureHardware == false, device lacks hardware-backed key storage.

                üî∏ 2. Fallback Strategy for Non-Secure Hardware (Android)
                        | Capability            | Fallback                                                                                              |
                        | --------------------- | ----------------------------------------------------------------------------------------------------- |
                        | Secure key generation | Use software-based Keystore + enforced biometric access                                               |
                        | Key protection        | Encrypt sensitive keys with passphrase-derived key (PBKDF2) stored in memory only                     |
                        | Key attestation       | Use Play Integrity API to validate device integrity at runtime                                        |
                        | On-device crypto      | Use software crypto (e.g., BouncyCastle or libsodium) with key derivation guarded by biometric gating |


                üîπ 3. Policy-Based Security Downgrade
                        If no StrongBox or secure TEE:
                                ‚Ä¢ Restrict high-risk operations:
                                        ‚Ä¢ Limit session duration
                                        ‚Ä¢ Require server-side re-auth for sensitive actions (e.g., wire transfers)
                                ‚Ä¢ Force additional factors:
                                        ‚Ä¢ App PIN or passphrase
                                        ‚Ä¢ OTP via secure channel
                                ‚Ä¢ Warn user about degraded security or unsupported device

                üî∏ 4. Backend-Driven Device Trust Scoring
                        ‚Ä¢ Score each device based on:
                                ‚Ä¢ Hardware support (StrongBox, SafetyNet verdicts)
                                ‚Ä¢ Attestation results
                                ‚Ä¢ OS patch level and bootloader status
                        ‚Ä¢ This allows server-side logic to decide what‚Äôs allowed per device. For example:
                                ‚Ä¢ Device A (Secure Enclave or StrongBox) ‚Üí full trust
                                ‚Ä¢ Device B (no TEE, CTS fail) ‚Üí restricted access or blocked

                üîπ 5. Bridge Parity with iOS
                        | Feature                         | iOS (Secure Enclave)           | Android Fallback                                 |
                        | ------------------------------- | ------------------------------ | ------------------------------------------------ |
                        | Biometric-gated key             | `LAContext + SecAccessControl` | Keystore + `setUserAuthenticationRequired(true)` |
                        | Hardware-backed key storage     | Always                         | StrongBox or fallback to software                |
                        | Attestation                     | Native + DeviceCheck           | Play Integrity + Key Attestation                 |
                        | Key invalidation on auth change | Built-in                       | `setInvalidatedByBiometricEnrollment(true)`      |

        ‚úÖ Final Answer (for Interview):
                When an Android device lacks StrongBox or hardware-backed Keystore, I fall back to using software-based Keystore with biometric gating, server-enforced policies, and device integrity validation via Play Integrity API. I reduce feature exposure for such devices and warn users if needed. To maintain parity with iOS‚Äôs Secure Enclave, I use a trust scoring system that aligns attestation signals and cryptographic guarantees across platforms, ensuring equivalent security posture even when the underlying hardware differs.

References:
        https://medium.com/@sofienrahmouni/securing-android-behind-a-few-seconds-of-payment-transaction-bf6817119d51
        https://developer.android.com/privacy-and-security/security-best-practices