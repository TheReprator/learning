Securing Android Application:
        üìå 1) Protecting Your App from Reverse Engineering & Debugging
                ‚Ä¢ Anti-Developer-Options: Check developer is enabled or not
                ‚Ä¢ Anti-Debugging: Detect debuggers at runtime
                ‚Ä¢ Anti-Root Detection: The key to most attack starts with obtaining privileged access as an admin or root user. Therefore, we must protect our 
                                       application by implementing root detection
                ‚Ä¢ Obfuscation: It is basically a process to change the name of file, variable to some random, to make to it difficult for reverse decoding or decompilation.
                               Android offers open-source obfuscation tools such as ProGuard and R8, as well as more advanced paid options like DexGuard
                ‚Ä¢ Anti-Tampering: 
                                 ‚Ä¢ Google Play Integrity API: It helps you check that interactions and server requests are coming from your genuine app binary running 
                                                             on a genuine Android device. 

                                        ‚Ä¢ Genuine app binary: Determine whether you're interacting with your unmodified binary that Google Play recognizes.
                                        ‚Ä¢ Genuine Play install: Determine whether the current user account is licensed, which means that the user installed or paid for 
                                                                your app or game on Google Play.
                                        ‚Ä¢ Genuine Android device: Determine whether your app is running on a genuine Play Protect certified Android-powered device 
                                                        (or a genuine instance of Google Play Games for PC).

                                 ‚Ä¢ APK Signature Verification: 
                                                        ‚Ä¢ It ensures that an app hasn't been tampered with. The process involves using the Android Open Source 
                                                          Project's APK signature scheme to verify the APK's integrity, including resources, code, and ZIP metadata. 

                                                        ‚Ä¢ Any modification to the APK, including ZIP metadata, invalidates the signature, preventing installation or operation 
                                                          of the tampered app. 

                                                        ‚Ä¢ It is recommended to perform this check on a remote server by sending the current certificate signature 
                                                           and comparing it on the server side.

                                ‚Ä¢ useEmbeddedDex: It is used to control how dex files are loaded in an app, particularly for apps that use custom class loading (such as 
                                                  plugin frameworks, multi-process apps, or dynamic feature loading).
                                                                It tells the Android system: "Do not optimize or transform dex files for this app. Keep them in raw .dex 
                                                  format inside the APK."


                                                üîπ What Problem Does It Solve?
                                                        By default, starting from Android 8.0 (API level 26), the Android runtime uses a mechanism called dex compression and optimization, such as CompactDex and other performance-focused formats, to optimize dex loading.

                                                        This is great for performance, but it breaks custom class loading scenarios where apps expect to load .dex files directly from APK assets or external locations ‚Äî because the dex files might not be stored in their raw, expected format anymore.

                                                ‚ö†Ô∏è Downsides
                                                        ‚Ä¢ Performance impact: Dex files are not optimized (no OAT/ART pre-compilation).
                                                        ‚Ä¢ Increased memory usage and slower startup due to lack of optimizations.

                                                ‚úÖ Use it only when you rely on manual dex/class loading, and are targeting Android 8.0+ where the default dex optimizations might break your logic and will be applicable from android 10(Api 29) and above.

                                                üîÅ How to use it:

                                                        // In the application element of the app's manifest file
                                                        android::useEmbeddedDex = true

                                                        // In the module-level build.gradle.kts file (or build.gradle file if using Groovy)
                                                        packagingOptions {
                                                                dex {
                                                                        useLegacyPackaging = false
                                                                }
                                                        }

                üìå 2) Securing Execution Environment
                        ‚Ä¢ Anti-Emulation: It is a techniques aim to prevent malware or protected applications from being reverse-engineered, debugged, or otherwise analyzed 
                                          by unauthorized parties often by using emulators or sandboxes.

                                          So here, we check for emulation like, the app should not be running on emulator, simulator or sandboxes or custom phone
                        ‚Ä¢ Anti-Sideloading: Restrict APK installation from untrusted sources, we recommand to download the application from Google play by checking the 
                                            vendor application.

                        ‚Ä¢ Anti-Multiwindow: Prevent multi-window mode to avoid overlay attacks, if it is possible, as we are en era of foldables and adaptive

                üìå 3)  Preventing Data Leakage & Unauthorized Access
                        ‚Ä¢ Log Protection: Avoid logging data in Prod
                        ‚Ä¢ Secure Database & Preference: We can use SQLCipher for encrypted database storage or save encrypted data directly in your 
                                DB and EncryptedSharedPreferences for shared Preference
                        ‚Ä¢ Secure Binding Services: 
                                        ‚Ä¢ set exported to false in manifest to respective android components, if we do not want to share anything with external vendors
                                        ‚Ä¢ Take care of binding flag, when using services or AIDL

                        ‚Ä¢ Anti-Screenshot & Overlay Detection:
                                        Use FLAG_SECURE to block screenshots and to block overlays using this flag permission android.permission.HIDE_OVERLAY_WINDOWS(introduced in Android 12). For oldest Android version, we can implement a custom solution to inject event in random touch and intercept it

                        ‚Ä¢ Anti-Camera & Microphone Abuse: Restrict background access using Android 10+ APIs and put some mechanism detection when camera is open and used 
                                        by another threat application

                        ‚Ä¢ Anti-Accessibility Exploits: Stop accessibilty for views that contain sensitive information like balace, CVV, Account No. etc.

                üìå 4) Strengthening Authentication & Secure Communication
                        ‚Ä¢ Biometric Authentication: Biometric API exist for strong user authentication like fingerprint, face, or iris which be used to verify the identity of 
                                                the user before doing any transaction.

                        ‚Ä¢ Secure Connection (TLS/SSL)

                        ‚Ä¢ HTTPS/SSL Security: To prevent Man-in-the-Middle (MITM) attacks, Android 7 (API 24) introduced the Network Security Config
                        ‚Ä¢ API Key Protection: 
                                ‚Ä¢ Gradle Properties or enviorment variables, and make sure that is not part of git commit
                                ‚Ä¢ Use NDK to store API-KEY inside a ‚Äú.cpp‚Äù file.

                üìå 5) Secure Cryptography & Key Management
                        ‚Ä¢ Secure Cryptography: 
                        ‚Ä¢ Key Rotation: Programming security is time-sensitive, and in this context, cryptographic keys must be regularly updated to mitigate potential risks. 
                                It is recommended not to exceed a 90-day lifespan for secure keys to ensure optimal protection.
                        ‚Ä¢ Use Secure Random: 

                üìå 6) Enhancing System Security & Updates
                        ‚Ä¢ Secure Elements & TEE (Trusted Execution Environment): As said in the last point, Android Keystore should be generated on Trusted Execution 
                           Environment (TEE) storage backed in StrongBox introduced in Android 9 (for lowest version, we can use software white box but it‚Äôs must be respect the security standard).

                        ‚Ä¢ GMS Security Updates: Google provides GMS (Google Mobile Services), which checks for any security updates. To verify this, we should check 
                                the currently installed version of Google Play Services

                        ‚Ä¢ Backup Security:
                                In Android, to retrieve your preferences after reinstalling an application, we use the backup mechanism. However, this represents a security issue, which is why it has been deprecated starting from Android 12 and may be removed in future versions. We recommend disabling auto-backups for sensitive data by setting android:allowBackup="false"

                        ‚Ä¢ CVE Patching & Dependency Updates:
                                In Android, we have a higher probability to use third party library which can represent a vulenrability risk, so before integrating any library, we must check the origin , the maintainers community, the latest support date .. and after that we should regularly update and check for CVEs and finally use only Stable version.

                üìå 7) Advanced Security Techniques
                        ‚Ä¢ Secure OpenGL: When using OpenGl, use the flag "EGL_PROTECTED_CONTENT_EXT" to protect rendering data to be read illegaly from the RAM memory
                        ‚Ä¢ Multiprocess Security: Try to run the service or Android component in a separte process via manifest, This helps to prevent unauthorized access
                                 by ensuring that each process operates in a separate environment, making it more difficult for one process to access the memory or data of another


References:
        https://medium.com/@sofienrahmouni/securing-android-behind-a-few-seconds-of-payment-transaction-bf6817119d51
        https://developer.android.com/privacy-and-security/security-best-practices